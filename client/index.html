<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.socket.io/socket.io-1.4.5.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="/client/two.min.js"></script>
    <script src="/client/url.js"></script>
    <link rel="stylesheet" type="text/css" href="/client/main.css"/>
	<title>Client!</title>
</head>
<body>
<div id="name"></div>
<div id="view"></div>

<script type="text/javascript">
var type = /(canvas|webgl)/.test(url.type) ? url.type : 'svg';
var elem = document.getElementById('view');
var two = new Two({ width: elem.width, height: elem.height }).appendTo(elem);

window.onresize=function(){
	two.width = $("#view").width();
	two.height = $("#view").height();
};

var numOfSteps = 5;

var id = -1;
var state = {'x': 0, 'y':0};
var animateState = {'x': 0, 'y':0};
var socket = io();
var circle = new Two.Ellipse(state.x, state.y, 50);
var group = new Two.Group();
var others = new Two.Group();
var otherGroups = {};
group.add(circle);
two.add(group);
two.add(others);

$("#view").click(onViewClick);

function onViewClick(event){
	var xOff = $(window).width()*0.05;
	var yOff = $(window).height()*0.05;
	state['x'] = event.clientX-xOff;
	state['y'] = event.clientY-yOff;
	updateSelf();
	sendState();
}

function updateSelf(){
	two.update();
}

function sendState(){
	emit('update_state', id, state);
}

socket.on('on_connect', function(msg){
	if(id<0){
		id = msg;
		$('#name').append("<p>MY NAME IS: "+id+"</p>");
	}
	emit('connect_ack', id, state);
});

socket.on('server_update', function(msg){
	temp={};
	for(var i in otherGroups){
		if(i in msg){
			temp[i] = otherGroups[i];
		}else{
			two.remove(otherGroups[i]);
		}
	}
	otherGroups = temp;
	for(var i in msg){
		var clientState = msg[i];
		if(i!=id && clientState!=null){
			if(i in otherGroups){
				//update group translation with clientstate
				otherGroups[i]['oldstate'] = shallowCopy(otherGroups[i]['newstate']);
				
				//otherGroups[i].translation.set(clientState.x, clientState.y);
				otherGroups[i]['newstate'] = clientState;
			}else{
				//make new entry with id, new group, with circle at origin, then translate
				otherGroups[i] = new Two.Group();
				otherGroups[i].add(new Two.Ellipse(0,0,25));
				otherGroups[i]['oldstate'] = clientState;
				otherGroups[i]['newstate'] = clientState;
				otherGroups[i].translation.set(clientState.x, clientState.y);
				two.add(otherGroups[i]);
			}
		}else if(i==id){
			emit("update_ack", id, state);
		}
	}
	console.log(otherGroups);
	two.update();
});


function emit(channel, clientID, clientData){
	var messagePack = {'ID':clientID, "STATE":clientData};
	socket.emit(channel, messagePack);
}


function updateObject(obj, newObj){
	if(newObj!=null){
		for(var key in obj){
			if(key in newObj){
				obj[key] = newObj[key];
			}
		}
		for(var key in newObj){
			if(!(key in obj)){
				obj[key] = newObj[key];
			}
		}
	}
}

two.bind('update', function(framecount){
	if(!statesEqual(animateState, state) && group!=null){
		var xStep = (state.x-animateState.x)/numOfSteps;
		var yStep = (state.y-animateState.y)/numOfSteps;
		group.translation.set(animateState.x+xStep, animateState.y+yStep);
		animateState.x = animateState.x+xStep;
		animateState.y = animateState.y+yStep;
	}



	
	for(var ident in otherGroups){
		var g = otherGroups[ident];
		if(g!=null){
			var targetState = g['newstate'];
			var currentState = g['oldstate'];
			if(targetState!=null && currentState!=null){
				if(!statesEqual(targetState, currentState)){
					
					var xStep = (targetState.x-currentState.x)/numOfSteps;
					var yStep = (targetState.y-currentState.y)/numOfSteps;
					g.translation.set(currentState.x+xStep, currentState.y+yStep);
					currentState.x = currentState.x+xStep;
					currentState.y = currentState.y+yStep;
					g['oldstate'] = currentState;
				}
			}
		}
	}

});
two.play();


function statesEqual(a, b){
	if(a!=null && b !=null){
		if(a.x===b.x && a.y===b.y){
			return true;
		}
	}
	return false;
}

function shallowCopy(s){
	var copyOBj = {};
	for(var prop in s){
		copyOBj[prop] = s[prop];
	}
	return copyOBj;
}


</script>

</body>
</html>